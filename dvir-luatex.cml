<?xml version="1.0" encoding="utf-8"?>
<html>
<head>
  <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
  </style>

  <!-- PDFjs code (more at the end of the document) -->
  <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script>

</head>
<body>
  <h1>The Agony and the Ecstacy: Adding LuaTeX support to 'dvir'</h1>
  <p>
    <span style="font-style: italic">by Paul Murrell</span>
    <a href="http://orcid.org"><img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle" /></a> <span style="font-family: mono; font-size: small"><a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a></span>
  </p>
  <p class="date">
    Version 1:
    <rcode echo="FALSE" results="asis">
cat(format(Sys.Date(), "%A %d %B %Y"))
    </rcode>
  </p>

  <rcode id="init" echo="FALSE" message="FALSE" results="hide">
opts_chunk$set(comment=" ", tidy=FALSE)
options(width=100)
## For wonky desktop set up
options(bitmapType="cairo")
  </rcode>
  <rcode echo="FALSE">
    library(grid)
  </rcode>

  <hr/>
  <p>
    <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/"><img class="CC"
    alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span
    xmlns:dct="http://purl.org/dc/terms/"
    property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#"
    property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
  <hr/>
  <p>
    This report describes an update to the 
    R package 'dvir' to add support for the LuaTeX engine.
    The immediate advantage of this support is the ability to
    draw typeset text in R with 
    a wider variety of fonts and font features.
  </p>

  <toc/>

  <rcode echo="FALSE" results="hide" message="FALSE" warning="FALSE">
## Make 'extrafont' aware of local font(s)
extrafont::font_import(".", prompt=FALSE)
  </rcode>

  <h2><a name="intro">The 'dvir' package</a></h2>
  <p>
    The idea behind the 'dvir' package (<a href="#pkg:dvir"/>,
    <a href="#murrell-dvir"/>) 
    is to be able to 
    typeset text using Donald Knuth's TeX system (<a href="#Knuth:1986:TEX:1102013"/>), 
    but render the result in R.
    The aim is to render the result using R graphics, but
    to obtain identical rendered output compared to the
    output 
    produced by a "normal" TeX renderer like <code>pdflatex</code>.
  </p>
  <p>
    For example, the following code typesets a simple equation
    using TeX and renders it in R.  The image below the code
    is text drawn in R using the locations and fonts dictated by TeX.
  </p>
<rcode id="demo-code" fig.width="2" fig.height=".5" warning="FALSE">
library(dvir)
grid.latex("$x - \\mu$")
</rcode>
  <p>
    The approach used by the 'dvir' package involves generating DVI
    output from TeX code.  This DVI output provides 
    precise information about every individual character of text,
    including where to draw each character and which font to use.  The 'dvir' 
    package reads the DVI information and converts it to 
    'grid' grobs (graphical objects) for rendering in R.
  </p>
  <p>
    One of the major limitations of 'dvir' version 0.1-0 was that it was focused
    just on the TeX Computer Modern fonts.  This produces nice mathematical
    equations, but for normal text can be quite limiting.
  </p>

  <h2><a name="luatex">The LuaTeX engine</a></h2>
  <p>
    The LuaTeX engine (<a href="#luatex"/>)
    differs from the original TeX engine in several
    important ways:<a href="#terminology"/>  
    it works with Unicode text (so it is easy to 
    specify a very wide range of characters);  it provides support for 
    modern font technologies like TrueType and OpenType;  and it
    has an embedded scripting language (called Lua).
  </p>
  <p>
    The first two of those features mean that, if we can add 
    support for the LuaTeX engine to 'dvir', we will be able to produce
    a much wider range of typeset text in R graphics.
  </p>

  <h2><a name="dvir-luatex">Adding LuaTeX support to 'dvir'</a></h2>
  <p>
    From a user perspective, there is not much to tell.
    This is the "ecstacy";
    when everything works as planned, 
    we get R graphics output that contains TeX-quality typesetting.
  </p>
  <p>
    As a simple example, 
    the following LuaTeX document,
    <code>luatex-demo.tex</code>,
    contains simple text that 
    makes use of a Lato Light (non-Computer-Modern) font,
    within a paragraph that is 3 inches wide.
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-demo.tex"), sep="\n")
  </rcode>
  <p>
    The following R code runs LuaTeX to typeset the text
    and generate DVI output, reads the DVI output into R
    and generates 'grid' grobs, then draws the grobs on an
    R graphics device.
  </p>
  <rcode fig.width="3" fig.height="1">
library(dvir)
grid.latex(readLines("luatex-demo.tex"), 
           engine=luatexEngine, 
           preamble="", postamble="")
  </rcode>
  <p>
    The new features of this code, compared to the previous version
    of 'dvir', are the new arguments to <code>grid.latex</code>:
    <code>engine</code>, to specify that we want to use the
    LuaTeX engine, rather than the standard TeX engine; and
    <code>preamble</code> and <code>postamble</code>, which allow
    us to use a complete LuaTeX document as input, rather than
    automatically wrapping the input with LaTeX begin/end document 
    code.
  </p>
  <p>
    The next section goes into the technical detail
    of getting LuaTeX support in 'dvir'.  
    It is safe to skip ahead to the 
    <a href="#examples"/> Section, which contains more elaborate demonstrations
    of LuaTeX output within R graphics.
  </p>
  
  <h2><a name="details">Technical details</a></h2>
  <p>
    This section describes the technical details of adding LuaTeX support.
    This is the "agony".
  </p>
  <p>
    This detailed description 
    serves two purposes:  when things do not work as planned, these
    details may provide some suggestions for what went wrong (and perhaps
    even how to fix it);  and this is an important record of the internal
    design, which is complicated, and will certainly be forgotten if 
    not recorded properly.
  </p>
  
  <h3>DVI output from LuaTeX</h3>
  <p>
    The normal way to use LuaTeX is to run 
    the <code>lualatex</code> program on a LuaTeX document, which produces 
    a typeset PDF document.  However, the 'dvir' package consumes DVI
    files, which we can get from LuaTeX by running
    the <code>dvilualatex</code> program instead.
  </p>
  <p>
    The following bash code generates a DVI file,
    <code>luatex-demo.dvi</code>,
    from the simple LuaTeX document, <code>luatex-demo.tex</code>,
    which was shown above.    
  </p>
  <bash results="hide">
dvilualatex luatex-demo.tex
  </bash>
  <p>
    The DVI file mostly consists of the usual instructions that adjust
    the drawing location,
    like <code>right3</code> and <code>down3</code>,
    and the usual instructions to draw a character, like
    <code>set_char_83</code> (an 'S' character).
    However,
    One major difference between this DVI output from <code>dvilualatex</code>
    and the DVI output
    from <code>latex</code> is the <code>fnt_def</code> instruction,
    which defines a font to use for drawing text, and
    in particular its <code>fontname</code> parameter.
  </p>
  <rcode id="readdvi" eval="FALSE">
readDVI("luatex-demo.dvi")
  </rcode>
  <rcode echo="FALSE">
dvi <- 
<<readdvi>>
cat(capture.output(print(dvi))[1:15], sep="\n")
  </rcode>
  <p>
    With the TeX engine, and standard Computer Modern fonts, the
    <code>fontname</code> is just the name of a font, like <code>cmr12</code>
    (meaning Computer Modern Roman at 12 pt size).
    The <code>fontname</code> in the DVI above contains a font name,
    plus additional information about how the font is being used.
  </p>
  <p>
    So the first complication for 'dvir' with LuaTeX support
    is that we must pull out the information that
    we need from the <code>fontname</code> parameter in
    <code>fnt_def</code> instructions.  For now, we will just
    grab the font name
    at the start, in this case, <code>LatoLight</code>.  We will come
    back to some of the other information later.
  </p>
  <!-- 
       mode=node means that we are dealing with a "more complex font"
       otherwise mode=base (invisibly?)
       See http://www.pragma-ade.com/general/manuals/luatex.pdf page 79
  -->

  <h3>Resolving LuaTeX font names</h3>
  <p>
    Having a font name is actually sufficient to draw some text on
    some graphics devices in R.  For example, the Cairo graphics
    devices can make use of just the font name, as shown below.
  </p>
  <rcode fig.keep="none" results="hide">
library(grid)
png("LatoLight.png", type="cairo", width=300, height=50)
grid.text("Some text in Lato Light font.",
          gp=gpar(fontfamily="LatoLight"))
dev.off()
  </rcode>
  <p>
    <img src="LatoLight.png" alt="Text drawn in R using Lato Light font"/>
  </p>
  <p>
    However, this does not work for all LuaTeX text 
    or for all R graphics devices;
    as we will see, what we really need is the actual font file that corresponds
    to the font that LuaTeX used.
    Fortunately, LuaTeX includes a tool called <code>luaotfload-tool</code>
    that can help us.
  </p>
  <bash>
luaotfload-tool --find=LatoLight
  </bash>
  <p>
    This font file will allow us to find out much more about the font
    than just its name and that will help us to use the
    font on other graphics devices and for more complex text.
  </p>

  <h3>Determining which character to draw</h3>
  <p>
    The simple LuaTeX example above only makes use of ASCII characters.
    This means that all of the DVI instructions to draw a character in
    that example are of
    the form <code>set_char_<i>n</i></code>. The <code><i>n</i></code>
    gives the <a href="https://theasciicode.com.ar/">ASCII encoding</a>
    for the character: e.g., 
    <code>set_char_83</code> means a capital 'S' character.
  </p>
  <p>
    However, LuaTeX documents support Unicode text, so we can have,
    for example, text with accents or diacritics, like the
    c-cedilla, ç, in the document below.
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-demo-unicode.tex"), sep="\n")
  </rcode>
  <p>
    We can generate a DVI file with <code>dvilualatex</code> as before ...
  </p>
  <bash results="hide">
dvilualatex luatex-demo-unicode.tex
  </bash>
  <p>
    ... and the start of this DVI file is very much like the previous one
    (just with the 'D' from "Du" instead of the 'S' from "Some").
  </p>
  <rcode id="readdvi-unicode" eval="FALSE">
readDVI("luatex-demo-unicode.dvi")
  </rcode>
  <rcode echo="FALSE">
dvi <- 
<<readdvi-unicode>>
dviprint <- capture.output(print(dvi))
cat(dviprint[1:15], sep="\n")
  </rcode>
  <p>
    However, if we look at the DVI information for the
    text around the word "français", we see a <code>set_char1</code>
    instruction (a single byte character outside the range 0-127),
    with a parameter <code>e7</code>.  
  </p>
  <rcode echo="FALSE">
ccedilla <- grep("set_char1", dviprint)
cat(dviprint[ccedilla + -3:3], sep="\n")
  </rcode>
  <p>
    This shows how LuaTeX expresses Unicode text (within the range 128-255).
    The value <code>e7</code> is a UTF16BE encoding for the Unicode character
    "LATIN SMALL LETTER C WITH CEDILLA" (the full encoding is <code>00e7</code>,
    but the <code>00</code> is dropped to allow the DVI to just record
    a single byte).
  </p>
  <p>
    The next example demonstrates a full 2-byte UTF16BE encoding.
    This time we have a LuaTeX document that contains the character
    sequence "fi" (in the word "fine").
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-demo-flig.tex"), sep="\n")
  </rcode>
  <bash results="hide">
dvilualatex luatex-demo-flig.tex
  </bash>
  <p>
    If we look at the DVI information around the word "fine",
    we see two interesting points:  the "fi" has been reduced down to
    a single character;  and that character is expressed as a 
    <code>set_char2</code> instruction (a 2-byte character), 
    with parameter <code>fb 01</code>.
  </p>
  <rcode id="readdvi-flig" eval="FALSE">
readDVI("luatex-demo-flig.dvi")
  </rcode>
  <rcode echo="FALSE">
dvi <- 
<<readdvi-flig>>
dviprint <- capture.output(print(dvi))
fi <- grep("set_char2", dviprint)
cat(dviprint[fi + -3:3], sep="\n")
  </rcode>
  <p>
    What has happened is that LuaTeX has replaced 
    the two characters 'f' followed by 'i' with a single <str>ligature</str>
    character that combines the 'f' and the 'i' (to deal with the fact that
    the top of the 'f' and the dot on the 'i' may interfere with each
    other). The value <code>fb 01</code> 
    is the UTF16BE encoding for the Unicode character 'LATIN SMALL 
    LIGATURE FI'.
  </p>
  <p>
    So another part of supporting LuaTeX in 'dvir' is being able to
    convert these UTF16BE encodings into something that R understands.
    The 'dvir' package uses the <code>iconv</code> function to 
    perform this conversion.
  </p>
  <rcode>
iconv(list(as.raw(as.hexmode(c("00", "e7")))), from="UTF16BE", to="UTF-8")
iconv(list(as.raw(as.hexmode(c("fb", "01")))), from="UTF16BE", to="UTF-8")
  </rcode>
  <p>
    These UTF-8 character values are 
    sufficient for drawing on Cairo-based R graphics devices
    at least, because the Cairo graphics device handles UTF-8 text.  
    We will hopefully come back to the issue of 
    other graphics devices later.
  </p>
  <p>
    The next example increases the complexity significantly.
    In this LuaTeX document, we have the character sequence "ti"
    (in the word "timely").
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-demo-tlig.tex"), sep="\n")
  </rcode>
  <p>
    If we look at the DVI information around the word "timely",
    we again see that the "ti" has been reduced down to
    a single character (a ligature) and this time we have a 
    <code>set_char3</code> instruction (a 3-byte character), 
    with parameter <code>0f 02 d5</code>.
  </p>
  <bash results="hide">
dvilualatex luatex-demo-tlig.tex
  </bash>
  <rcode id="readdvi-tlig" eval="FALSE">
readDVI("luatex-demo-tlig.dvi")
  </rcode>
  <rcode echo="FALSE">
dvi <- 
<<readdvi-tlig>>
dviprint <- capture.output(print(dvi))
ti <- grep("set_char3", dviprint)
cat(dviprint[ti + -3:3], sep="\n")
  </rcode>
  <p>
    Similar to the "fi" example, the "ti" character sequence
    has been reduced to a single ligature.  However, this example
    is more complicated because the "ti" ligature does not exist 
    in Unicode.  The bytes <code>0f 02 d5</code> do not represent
    an encoding for a Unicode character.
  </p>
  <p>
    This lack of Unicode representation 
    presents two problems:  how do we map the <code>0f 02 d5</code>
    value to an R character value?  and how do we express that character 
    to an R graphics device?
  </p>

  <h3>Non-unicode characters in LuaTeX DVI output</h3>
  <p>
    The fact that LuaTeX has generated DVI information with
    3 bytes (with <code>0f</code> as the
    first byte) is an indication that the character we need to draw
    is not a Unicode character.
  </p>
  <p>
    The remaining two bytes, in this case <code>02 d5</code>, are an 
    integer index, in this case 725, that means we should use the 725th
    non-Unicode character in the current font.  To be more accurate, it means
    that we should use the 725th
    non-Unicode <str>glyph</str> in the current font.
  </p>
  <p>
    If the expression "the 725th
    non-Unicode glyph in the current font" seems confusing to you,
    you are not alone.  We need to unpack it a little to understand 
    what is going on.
  </p>
  <p>
    First of all, a character is a concept, while a glyph is a concrete
    symbol representing that concept.  The character 'A' is represented
    by different glyphs in different fonts; the 
    '<span style="font-family: Times New Roman, serif">A</span>' in a serif font like
    Times New Roman looks different
    to the 
    '<span style="font-family: Courier, monospace">A</span>' in a monospace font
    like Courier.
  </p>
  <p>
    A font is a collection of glyphs, most of which are shapes representing
    characters.  A font also contains (or refers to) an <str>encoding</str>,
    which maps each glyph to a numeric value.  For example, the Lato Light
    font contains a glyph representing the character 'S' and an 
    encoding that maps 'S' glyph to the number 83.  It also
    contains a glyph representing the "fi" ligature and an encoding
    that maps the "fi" ligature glyph to the number 64257 (<code>fb 01</code>
    in hexadecimal form).
  </p>
  <p>
    Normally, when we draw text, we specify the characters to draw,
    the font to use, and (often implicitly) an encoding.  The 
    encoding maps the characters to the correct glyph within the font.
  </p>
  <p>
    If we ignore the encoding, a font consists of just a collection of
    glyphs, from 1 to the number of glyphs in the font.  We do not
    usually access fonts this way, but the TTX tool (part of
    the fonttools project; <a href="#fonttools"/>) 
    can extract this information for us.
    The following code extracts the names and order of the 
    glyphs (the <str>GlyphOrder</str> table) from the font file
    <code>Lato-Light.ttf</code> to a new file called 
    <code>Lato-Light-GlyphOrder.ttx</code>.
  </p>
  <bash>
cp /usr/share/fonts/truetype/lato/Lato-Light.ttf Fonts/
  </bash>
  <bash results="hide">    
ttx -t GlyphOrder -o Fonts/Lato-Light-GlyphOrder.ttx Fonts/Lato-Light.ttf
  </bash>
  <p>
    Looking at the start of the 
    <code>Lato-Light-GlyphOrder.ttx</code> file,
    we can see that the glyph for 'A' is the fourth glyph in the font.
  </p>
  <bash>
head Fonts/Lato-Light-GlyphOrder.ttx
  </bash>
  <p>
    The glyph for 'S' is the 26th glyph (NOT the 83rd).
  </p>
  <bash>
grep -C 3 '"S"' Fonts/Lato-Light-GlyphOrder.ttx
  </bash>
  <p>
    The "fi" ligature glyph is the 42nd glyph.
  </p>
  <bash>
grep -C 3 FB01 Fonts/Lato-Light-GlyphOrder.ttx
  </bash>
  <p>
    What we can also see from this TTX output is that each glyph has
    a name.  In some cases, the name is quite familiar, e.g., <code>"A"</code>
    or <code>"S"</code> and in other cases, the name is less familiar, but still
    useful, because it points us to the Unicode code point for the glyph, e.g.,
    <code>"uniFB01"</code> for the "fi" ligature.  But there is a third
    set of glyph names that are totally inscrutable.  These names are of
    the form <code>"glyph<i>i</i></code>, where <i>i</i> simply reflects the
    rank of the glyph within the font.  
  </p>
  <bash>
grep -C 3 glyph Fonts/Lato-Light-GlyphOrder.ttx | head -7
  </bash>
  <p>
    If we treat glyphs with an inscrutable name as non-Unicode glyphs,
    we can find the 725th non-Unicode glyph within the font.
    The "ti" glyph is the 2472nd glyph in the font.
    (We have two off-by-one adjustments here, at least one of which
    is just accounting for zero-based versus one-based indexing.)
  </p>
  <bash>
grep glyph Fonts/Lato-Light-GlyphOrder.ttx | sed '724q;d'
  </bash>
  <p>
    The image below shows glyph number 2471 from <code>Lato-Light.ttf</code>
    (viewed with FontForge; <a href="#fontforge"/>).
  </p>
  <p>
    <img src="ti_lig.png" 
         alt="fontforge window showing glyph 2471 from Lato-Light.ttf"/>
  </p>
  <p>
    This gives us the name of the glyph within the font, in this case
    <code>glyph02471</code>.
  </p>

  <h3>Non-Unicode characters in R graphics output</h3>
  <p>
    Having established which glyph within the font LuaTeX is 
    referring to, we are still left with the problem of
    actually accessing that glyph from within R.
    When we draw text in R, what gets sent to an R graphics device 
    is a character value, not a glyph number.  We need a 
    way to specify a character value that selects the glyph 
    that we want.
  </p>
  <p>
    The approach taken by 'dvir' to solve this problem involves 
    creating a new mini-font that just contains the non-Unicode glyph
    (with an encoding that maps the glyph to an ASCII character).
    This requires several steps.
  </p>
  <p>
    We can extract a single glyph from a font using 
    <code>pyftsubset</code> from fonttools.  
    The following code extracts glyph 2471 from <code>Lato-Light.ttf</code>
    and saves it in a new font called <code>Lato-Light-glyph02471.ttf</code>.
    The <code>name-IDs</code> argument will be explained later.
  </p>
  <bash results="hide">
pyftsubset Fonts/Lato-Light.ttf --gids=2471 --output-file=Fonts/Lato-Light-glyph02471.ttf --name-IDs='*'
  </bash>
  <p>
    This new font contains no encoding, so the glyph within it is still
    inaccessible.  Furthermore, the new font has exactly the same name
    as the old font, which will make it difficult to specify this new font
    separately from the original font.
    To rename the font and 
    add the encoding, we can convert the font to an
    XML format, with TTX, insert an encoding (a <str>cmap</str> table),
    and then convert back to TrueType format.
  </p>
  <p>
    The following code converts the TrueType font to XML.
  </p>
  <bash echo="FALSE">
rm Fonts/Lato-Light-glyph02471.ttx
  </bash>
  <bash results="hide">
ttx Fonts/Lato-Light-glyph02471.ttf
  </bash>
  <p>
    In order to insert a cmap table, we need to know the name
    of the glyph in the new font.  Unfortunately, this is not 
    the same as the name of the glyph in the original font.
    The following code shows the GlyphOrder table for the new font.
  </p>
  <rcode>
library(xml2)
ttx <- read_xml("Fonts/Lato-Light-glyph02471.ttx")
xml_find_first(ttx, "//GlyphOrder")
  </rcode>
  <p>
    There are a couple of surprises: there is a <code>.notdef</code> 
    glyph that we did not ask for (we always get this);  none of
    the glyphs are called <code>glyph02417</code>;  and there
    are four glyphs besides <code>.notdef</code>,
    not just the one we asked for.
  </p>
  <p>
    This has happened because the glyph that we want is actually composed
    from several other glyphs in the original font.  We can see this
    by looking at the <str>glyf</str> table of the original font.
  </p>
  <bash results="hide">    
ttx -t glyf -o Fonts/Lato-Light-glyf.ttx Fonts/Lato-Light.ttf
  </bash>
  <rcode>
ttx <- read_xml("Fonts/Lato-Light-glyf.ttx")
xml_find_first(ttx, "//TTGlyph[@name = 'glyph02471']")
  </rcode>
  <p>
    When there are no <code>component</code> elements, the glyph we
    want will be the only glyph in the subsetted font, so we can just
    use <code>glyph00001</code> from the new font.  But when the
    glyph we want is composed from other glyphs, the subsetted font
    will contain several glyphs, in this case four (the glyph we
    want plus the three that it was composed from).
  </p>
  <p>
    There is now the problem of figuring out which of these four glyphs 
    is the glyph that we want.  To do this, we need to look at the
    names of the four glyphs and find out what order they are arranged
    in within the original font (and assume that that order is
    retained in the subsetted font).
  </p>
  <p>
    In this case, the answer is quite simple because the names of the
    glyphs tell us their order;  <code>glyph02471</code> is the third
    out of these four glyphs.  
  </p>
  <p>
    In general, we can match the names of the glyphs from the glyf 
    table to glyph names in the GlyphOrder table to determine their order.
  </p>
  <p>
    In summary, the glyph that we want in the subsetted font has the name
    <code>glyph00003</code>.
    The R code below inserts a cmap table that
    maps the number 65 (hex 41, ASCII for character "A") to 
    <code>glyph00003</code> in the new font.
  </p>
  <rcode>
ttx <- read_xml("Fonts/Lato-Light-glyph02471.ttx")
cmap <- xml_find_first(ttx, "//cmap")
cmapTable <-
    read_xml('<cmap_format_4 platformID="0" platEncID="3" language="0"/>')
xml_add_child(cmapTable, "map", code="0x41", name="glyph00003")
xml_add_child(cmap, cmapTable)
  </rcode>
  <rcode echo="FALSE">
cat(as.character(cmap), sep="\n")
  </rcode>
  <p>
    A similar approach can be used to give the new font a different name,
    by editing the <str>name</str> table within the XML.
    The <code>name-IDs</code> argument that we saw earlier in the
    call to <code>pyftsubset</code> exports the existing font name,
    so in this step we are just modifying the name table rather than
    creating a new one from scratch.
    The following code changes the "Font Family" name;  in the
    full code, we also modify the "Full" font name, which includes 
    possible modifiers like "Bold" or "Light", and the PostScript
    name for the font.
  </p>
  <rcode results="hide">
name <- xml_find_first(ttx, "//name")
familyname <- xml_find_first(name, "namerecord[@nameID = '1']")
xml_set_text(familyname, "custom_font_1")
  </rcode>
  <rcode echo="FALSE" results="hide">
## replace more names
newName <- read_xml("<name/>")
subfamilyname <- xml_find_first(name, "namerecord[@nameID = '2']")
fullname <- xml_find_first(name, "namerecord[@nameID = '4']")
xml_set_text(fullname, paste("custom_font_1", xml_text(subfamilyname)))
psname <- xml_find_first(name, "namerecord[@nameID = '6']")
xml_set_text(psname, "custom_font_1")
xml_add_child(newName, familyname)
xml_add_child(newName, subfamilyname)
xml_add_child(newName, fullname)
xml_add_child(newName, psname)
xml_replace(name, newName)    
  </rcode>
  <p>
    Finally, we write the modified XML to a new file and 
    reverse the conversion from XML back to a TrueType font.
  </p>
  <rcode>
write_xml(ttx, "Fonts/Lato-Light-glyph02471-enc.ttx")
  </rcode>
  <bash echo="FALSE">
rm Fonts/Lato-Light-glyph02471-enc.ttf
  </bash>
  <bash results="hide">
ttx Fonts/Lato-Light-glyph02471-enc.ttx
  </bash>
  <p>
    We can use <code>fc-scan</code> to see that the new font has 
    a different name from the original font.
  </p>
  <bash>
fc-scan Fonts/Lato-Light.ttf | grep family:
  </bash>
  <bash>
fc-scan Fonts/Lato-Light-glyph02471-enc.ttf | grep family:
  </bash>
  <p>
    The last step (for Cairo graphics devices in R) is to make sure that
    Fontconfig (<a href="#fontconfig"/>, <a href="#packard"/>) 
    can see the new font.  This can be done by creating
    a configuration
    file, as shown below, and placing that in a directory that 
    Fontconfig can see.
  </p>
  <rcode echo="FALSE">
temp <- readLines("font.conf.template")
temp[grep("PATH", temp)] <- gsub("PATH", getwd(), temp[grep("PATH", temp)])
writeLines(temp, "99-custom-font.conf")
  </rcode>
  <rcode echo="FALSE">
cat(readLines("99-custom-font.conf"), sep="\n")
  </rcode>
  <rcode results="hide">
file.copy("99-custom-font.conf", "~/.fonts.conf.d/", overwrite=TRUE)
file.copy("99-custom-font.conf", "~/fontconfig/conf.d/", overwrite=TRUE)
  </rcode>
  <p>
    We also need to force FontConfig to look at this new configuration,
    which we can do 
    using the 'systemfonts' package (<a href="#pkg:systemfonts"/>).
  </p>
  <rcode>
systemfonts::reset_font_cache()
  </rcode>
  <p>
    From R, we can select this font and draw the "ti" ligature
    by asking the font for an 'A' character.
  </p>
  <rcode fig.keep="none" results="hide">
png("LatoLight-ti_lig.png", type="cairo", width=200, height=50)
grid.text("A",
          gp=gpar(fontfamily="custom_font_1", cex=3))
dev.off()
  </rcode>
  <p>
    <img src="LatoLight-ti_lig.png" 
         alt="A ti ligature drawn in R using a subset of the Lato Light font"/>
  </p>
  <p>
    Because R graphics can only use one font for drawing a piece of text,
    we have to draw this special character as an individual piece of text.
    However, this is how 'dvir' works generally, because the DVI output
    that it works from contains information about every individual
    character, so this is not a problem (or at least not a new problem).
  </p>

  <h3>Character metrics</h3>
  <p>
    The DVI output that 'dvir' is working from contains two
    types of 
    adjustments to the drawing location: explicit moves, 
    e.g., the space between words
    and kerning adjustments between letters;  and implicit moves based on
    instructions to
    draw a character.  The latter adjusts the drawing location
    so that we can just draw the next character alongside this character
    (if this is not the end of a word and there is no kerning).
  </p>
  <p>
    We can see this in the DVI from our very first example.
    The <code>set_char_83</code> instruction draws an 'S', 
    which implicitly adjusts the current location to
    just after the 'S'.  
    The <code>right2</code> makes an explicit kerning adjustment.
    We then draw an 'o', which implicitly adjusts the location, and then
    an 'm', which implicitly adjusts the location.  
  </p>
  <rcode echo="FALSE">
dvi <- 
<<readdvi>>
dviprint <- capture.output(print(dvi))
So <- grep("set_char_83", dviprint)
cat(dviprint[So + -3:3], sep="\n")
  </rcode>
  <p>
    In order to make the implicit adjustments, we must figure out
    the width of a character (so that we can shift the current location
    to just after the character).
  </p>
  <p>
    R provides functions to calculate this <str>font metric</str> information,
    e.g., <code>grid::stringWidth</code> and 
    <code>grid::grobWidth</code>, but on some 
    Cairo graphics devices
    the information is not accurate enough (for drawing individual characters).
  </p>
  <p>
    The following code demonstrates this problem.  We create a 'grid'
    text grob containing the letter 'o' with the Lato Light font.
    We open a PDF graphics device (and load the 'extrafont' package
    so that PDF graphics devices can use system fonts like Lato Light)
    and calculate the width of the letter "o".  ("bigpts" 
    are PostScript's 1/72in, as compared to TeX "pts", which are 1/72.27in.)
  </p>
  <rcode message="FALSE">
tg <- textGrob("o", gp=gpar(fontfamily="Lato Light"))
library(extrafont)    
  </rcode>
  <rcode>
pdf("o-metric.pdf")
grid.draw(tg)
convertWidth(grobWidth(tg), "bigpts")
  </rcode>
  <rcode results="hide">
dev.off()
  </rcode>
  <p>
    Now we do the same thing on a Cario PDF graphics device,
    but we get a different width (because the Cairo graphics devices
    only get metric values to the nearest "pixel").
  </p>
  <rcode>
cairo_pdf("o-metric-cairo.pdf")
grid.draw(tg)
convertWidth(grobWidth(tg), "bigpts")
  </rcode>
  <rcode results="hide">
dev.off()
  </rcode>
  <p>
    What this means is that, in order to position text exactly the same as
    LuaTeX has described in its DVI output,
    we cannot use the Cairo graphics metric information.
  </p>
  <p>
    Two solutions to this problem have been implemented.
    In the previous version of 'dvir', using the TeX engine, a PDF graphics
    device is used to calculate character metrics
    even on Cairo PDF devices.
    In this new version of 'dvir', when we use the LuaTeX engine and
    a non-Computer Modern font,
    character metrics are calculated
    by extracting the information from the font file directly.
    This is because using a PDF graphics device to calculate character
    metrics would be difficult because we are trying to support 
    a very wide range of character input (Unicode).
  </p>
  <p>
    Again, the first step is to use TTX to extract metric information
    to an XML format.
  </p>
  <bash results="hide">
ttx -t hmtx -o Fonts/Lato-Light-hmtx.ttx Fonts/Lato-Light.ttf
  </bash>
  <p>
    We can see that the resulting file contains width information
    for each glyph in the font.
  </p>
  <bash>
head Fonts/Lato-Light-hmtx.ttx
  </bash>
  <p>
    One complication is determining the scale of those widths.
    This requires looking at the <str>head</str> table from the font,
    in particular the <code>unitsPerEm</code> information.
  </p>
  <bash results="hide">
ttx -t head -o Fonts/Lato-Light-head.ttx Fonts/Lato-Light.ttf
  </bash>
  <bash>
grep -C 3 unitsPerEm Fonts/Lato-Light-head.ttx
  </bash>
  <p>
    The character width, in points, is the font size (in whole points) 
    multiplied by the width metric (scaled to 1000 unitsPerEm and then
    scaled to a unit square).  The following code and output shows how
    we can obtain the correct width of a "o" character.
  </p>

  <bash>
grep -C 3 '"o"' Fonts/Lato-Light-hmtx.ttx
  </bash>
  
  <rcode>
12 * 1116/(2000/1000)/1000
  </rcode>
  <p>
    All that remains is to locate the correct character metric.
    We can see from <code>Lato-Light-hmtx.ttx</code> that this requires
    finding the correct glyph name for the character.
  </p>
  <p>
    The <a href="https://rsms.me/fonttools-docs/#the-ttx-file-format">fontTools</a>
    documentation describes how the glyph names in the TTX files are determined
    and 'dvir' attempts to mimic that in order
    to obtain an appropriate glyph name.  For example, an 'o' character
    will be a <code>set_char_111</code> (6F in hex) in DVI and we can use the
    <a href="https://github.com/adobe-type-tools/agl-aglfn/blob/master/glyphlist.txt">Adobe Glyph List</a>
    to map <code>006F</code> to the glyph name "o".
    Because the glyphs names in TTX output o not always use the
    Adobe Glyph List names, we also generate glyph names of the form
    <code>uniXXXX</code>, where <code>XXXX</code> is the relevant
    UTF8 code point.  Furthermore, in some fonts, a single glyph 
    may be used for multiple characters and,
    in that case, the font may not contain a
    glyph with the expected name.  To help with this case, we also
    generate a glyph name from the Unicode <str>cmap</str> table within a font
    (if it exists).
  </p>
  <p>
    For example, a "-" (dash or hyphen or "hyphen-minus") character 
    will be a <code>set_char_45</code> (2D in hex) in DVI.
    The Adobe Glyph List maps <code>002D</code> to the name "hyphen",
    so that is the first name that we will try.  Unfortunately, 
    a font may not contain a glyph named "hyphen".
  </p>
  <bash>
grep -c -i hyphen Fonts/Lato-Light-hmtx.ttx
  </bash>
  <p>
    We also try the glyph name <code>uni002D</code>, but in this case,
    there is no glyph of that name either.
  </p>
  <bash>
grep -c -i 002D Fonts/Lato-Light-hmtx.ttx
  </bash>
  <p>
    Finally, we look in the Unicode cmap table to see which glyph
    is being used for the code point <code>002D</code>.
  </p>
  <bash>
ttx -t cmap -o Fonts/Lato-Light-cmap.ttx Fonts/Lato-Light.ttf
  </bash>
  <bash>
xmllint --xpath "//cmap_format_4[@platformID='0']/map[@code='0x2d']" Fonts/Lato-Light-cmap.ttx
  </bash>
  <p>
    This tells us that the glyph <code>uni00AD</code> (a "soft hyphen") 
    is being used for code point <code>002D</code> ("hyphen-minus"),
    so we look for that name as well.  And there is metric information
    for that glyph.
  </p>
  <bash>
grep -i 00AD Fonts/Lato-Light-hmtx.ttx
  </bash>

  <h2><a name="examples">Examples</a></h2>
  <p>
    As demonstrated by the simple example in the Section 
    <a href="#dvir-luatex"/>, one benefit of adding LuaTeX support
    to the 'dvir' package is that we can easily make use of
    fonts beyond the Computer Modern family.  To be clear, this 
    is extending the range of fonts that we can use to
    draw text with TeX-quality typesetting in R graphics;
    it was already possible to draw a normal R character value with a wide
    range of fonts, but that sort of text is not typeset with any
    sophistication.
  </p>
  <p>
    The next example makes it clearer that we are <em>typesetting</em> text
    (using LuaTeX) rather than just relying on R's text-drawing facilities.
    The LuaTeX document below describes text with several interesting 
    features:  the main font is <a href="https://fonts.google.com/specimen/Economica">Economica</a> (a Google font that has been downloaded to a local file);
    the first line of text is bold;  and the remaining text is
    typeset in a paragraph with steadily decreasing line length.
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-float.tex"), sep="\n")    
  </rcode>
  <p>
    The following code combines that typeset text with an R plot (in R).
    First, we draw a simple barplot.
    Then we call <code>grid.latex</code> 
    from the 'dvir' package to typeset the text using LuaTeX and 
    draw the result within the R plot. Some of the clues that tell
    us this is typeset text rather than just R drawing a character value
    are the stretching of space between words (e.g., on the first line
    of non-bold text) and the hyphenation of some words at line breaks.
  </p>
  <rcode fig.keep="last">
barplot(GNP ~ Year, data = longley)
latex <- readLines("luatex-float.tex")
grid.latex(latex, engine=luatexEngine, preamble="", postamble="",
           x=unit(1, "npc") - unit(5, "in"),
           y=unit(1, "npc") - unit(1, "in"),
           just=c("left", "top"))
  </rcode>
  <p>
    The next example demonstrates that, in addition to providing 
    an easy way to select a wider range of fonts, adding LuaTeX 
    support to 'dvir' provides access to LuaTeX's sophisticated 
    font handling features.
    For example, the following LuaTeX document typesets the same
    piece of text twice:  once with the standard Computer Modern font
    (actually LuaTeX selects the Latin Modern font, but that is 
    very similar to Computer Modern)
    and once using the Lato Light
    font with so-called "discretionary" ligatures (ch, ct, ck) and
    "old-style" numerals (with varying heights and alignments) selected.
    These font features are not accessible from R's standard 
    text drawing functions.
  </p>
  <rcode echo="FALSE">
cat(readLines("luatex-features.tex"), sep="\n")    
  </rcode>
  <p>
    The following code draws the resulting typeset text in R.
  </p>
  <rcode fig.width="3" fig.height="1">
latex <- readLines("luatex-features.tex")
grid.latex(latex, engine=luatexEngine, preamble="", postamble="")
  </rcode>  
  <!--
    Permission to "reproduce" Thomas Rahlf's figure obtained.
  -->
  <p>
    The final example comes from
    Thomas Rahlf's "Data Visualisation with R" (<a href="#Rahlf2017Data"/>).
    In the original example in the book, an R plot is included within a LaTeX 
    document with the LaTeX text overlaid on the plot using the
    LaTeX package 'overpic' (i.e., using LaTeX to combine the plot and text).
    The example below demonstrates an R-driven alternative, where we
    overlay text on a plot using R to combine the two.
  </p>
  <p>
    The R code for the plot is provided in a 
    <a href="rahlf-plot.R">separate file</a> 
    (downloaded from the <a href="http://www.datavisualisation-r.com/data/">book
    web site</a>).  The result of running the code
    is shown below;  note the use of the Lato Light font
    for labelling.
  </p>
  <rcode echo="FALSE" message="FALSE" dev="png" dev.args="list(type='cairo')" fig.width="12" fig.height="9">
source("rahlf-plot.R")
  </rcode>
  <p>
    The LaTeX code that describes the text to overlay on the plot is shown below
    (also taken from the book web site).  Important points to note here
    are the use of Lato Light font and the fact that the text is 
    typeset in a two-column format.
  </p>
  <rcode echo="FALSE">
cat(readLines("rahlf-text.tex"), sep="\n")
  </rcode>
  <p>
    The following code performs the overlay of the text on the plot
    using 'dvir'.  A little bit of set up is necessary to convert
    the original 'graphics' plot to a 'grid' plot (using the 
    'gridGraphics' package; <a href="#pkg:gridgraphics"/>,
    <a href="#RJ-2015-012"/>), 
    but the drawing of the text requires 
    just a single function call to <code>grid.latex</code>.
  </p>
  <rcode message="FALSE" fig.keep="last" dev="png" dev.args="list(type='cairo')" fig.width="12" fig.height="9">
## Draw main plot
source("rahlf-plot.R")
latex <- readLines("rahlf-text.tex")
gridGraphics::grid.echo()
downViewport("graphics-plot-1")
## Add LuaTeX typeset text
grid.latex(latex, preamble="", postamble="", engine=luatexEngine, 
           x=unit(1, "cm"), y=unit(1, "npc") - unit(1, "cm"), 
           just=c("left", "top"))
  </rcode>
  <p>
    One important thing to note is how the text is positioned relative
    to the plot;  the top-left of the text is exactly 1cm in from the top-left
    corner of the plot region.  This very explicit and precise 
    positioning is in contrast to the LaTeX-driven approach of
    the original figure in Rahlf's book.  The relevant piece of LaTeX
    code that performs the positioning in that case is shown below;
    the position <code>(60,128)</code>, which dictates the location of 
    the text on the plot, is 6cm in and 12.8 cm up 
    from the bottom-left of the entire plot
    image; it is not relative to the plot region within the plot.
    That is very much a trial-and-error location compared
    to the deliberate and expressive positioning that is possible 
    when combining the text with the plot in R.
  </p>
  <pre>
\begin{overpic}[scale=1,unit=1mm]{timeseries_areas_below_inc.pdf}
\put(60,128)
  </pre>
  
  <h2><a name="discussion">Discussion</a></h2>
  <p>
    The 'dvir' package provides a way to include typeset text within
    an R plot.
    The new version of the 'dvir' package, which adds support for the
    LuaTeX engine, provides access to a much
    wider range of typeset text, including a wider range of fonts.
  </p>
  <p>
    On the downside, many limitations of the original package remain.
    Drawing is very slow and support is only limited to 
    specific R graphics devices (so far).  Even worse, LuaTeX support 
    is only offered for Cairo-based graphics devices (at this point).
    Furthermore, the package has only been tested (and is only expected
    to run) on Linux;  it only makes use of Linux-based font-related tools
    like FontConfig and fonttools. This package remains a proof-of-concept.
  </p>
  <p>
    On the other hand, for anyone working
    on Linux and/or prepared to make use of Docker it might provide
    a way to produce graphical results that are not obtainable any
    other way.
  </p>
  <p>
    When the package does not produce the desired result, 
    the most likely source of problems is fonts.
    LuaTeX may make use of system fonts or TeX fonts.
    For system fonts, 'dvir' uses 'extrafont' to specify the
    font to R graphics.
    If a font is not found, 
    try running <code>extrafont::font_import</code> first to make sure that
    'extrafont' knows about all of your fonts and/or install additional
    font packages on your system.
    The <code>extrafont::font_import()</code> function
    can also be used to make sure that 'dvir' knows about local fonts that are 
    not installed on the system (like the Economica font used in one
    example in this report).
  </p>

  <h2><a name="requirements">Technical requirements</a></h2>
  <p>
    The examples and discussion in this document relate to <a
    href="https://github.com/pmur002/dvir/releases/tag/v0.2-0">version
    0.2-0</a> of the 'dvir' package and
    <a href="https://github.com/r-lib/systemfonts">the development version</a>
    of the 'systemfonts' package (for the <code>reset_font_cache</code> 
    function).
  </p>
  <p>
    This report was generated within a Docker container
    (see <a href="#Resources">Resources</a> section below).
  </p>

  <h2><a name="Resources">Resources</a></h2>
  <ul>
    <li>
      The <a href="dvir-luatex.cml">raw source file</a> for this
      report, a <a href="dvir-luatex.xml">valid XML</a>
      transformation of the source file, a <a
      href="dvir-luatex.Rhtml">'knitr' document</a> generated from
      the XML file, 
      two <a href="toc.R">R</a> <a href="bib.R">files</a> and
      the <a href="dvir-luatex.bib">bibtex file</a>
      that are used to generate the table of contents and reference sections,
      two <a href="common.xsl">XSL</a> <a
      href="knitr.xsl">files</a> and an 
      <a href="knit.R">R file</a> that are used to transform the XML to
      the 'knitr' document, and a <a href="Makefile">Makefile</a> that
      contains code for the other transformations and coordinates
      everything.  
      These materials are also available
      on <a href="https://github.com/pmur002/dvir-luatex-report/releases/tag/v1">github</a>.
    </li>
    <li>
      The LaTeX documents used in examples are:
      <a href="luatex-demo.tex"><code>luatex-demo.tex</code></a>,
      <a href="luatex-demo-unicode.tex"><code>luatex-demo-unicode.tex</code></a>,
      <a href="luatex-demo-flig.tex"><code>luatex-demo-flig.tex</code></a>,
      <a href="luatex-demo-tlig.tex"><code>luatex-demo-tlig.tex</code></a>,
      <a href="luatex-float.tex"><code>luatex-float.tex</code></a>, 
      and
      <a href="luatex-features.tex"><code>luatex-features.tex</code></a>.
      The files for Thomas Rahlf's figure are:
      <a href="rahlf-plot.R"><code>rahlf-plot.R</code></a> for the plot and
      <a href="rahlf-text.tex"><code>rahlf-text.tex</code></a> for the text.
      The example FontConfig configuration file is:
      <a href="99-custom-font.conf"><code>99-custom-font.conf</code></a>.
    </li>
    <li>
      This report was generated within a 
      <a href="https://www.docker.com/">Docker</a> container.
      The Docker command to build the report is included in the Makefile above.
      The Docker image for the container is available from
      <a href="https://hub.docker.com/r/pmur002/dvir-luatex/">Docker Hub</a>;
      alternatively, the image can be rebuilt from its 
      <a href="Dockerfile">Dockerfile</a>.
    </li>
  </ul>

  <h2>How to cite this document</h2>
  <p>
    Murrell, P. (2020). 
    "The Agony and the Ecstacy: Adding LuaTeX support to 'dvir'" 
    Technical Report 2020-??, Department of Statistics, The University of Auckland. 
    [ <a href="how-to-cite.bib">bib</a> ] 
  </p>

  <h2><a name="references">References</a></h2>
  <ul style="list-style-type: none">
    <li>
      <a name="R"/>
    </li>
    <li>
      <a name="luatex"/>
    </li>
    <li>
      <a name="pkg:dvir"/>
    </li>
    <li>
      <a name="murrell-dvir"/>
    </li>
    <li>
      <a name="Knuth:1986:TEX:1102013"/>
    </li>
    <li>
      <a name="fonttools"/>
    </li>
    <li>
      <a name="fontforge"/>
    </li>
    <li>
      <a name="fontconfig"/>
    </li>
    <li>
      <a name="packard"/>
    </li>
    <li>
      <a name="RJ-2015-012"/>
    </li>
    <li>
      <a name="pkg:gridgraphics"/>
    </li>
    <li>
      <a name="Rahlf2017Data"/>
    </li>
    <li>
      <a name="pkg:systemfonts"/>
    </li>
  </ul>

  <h2>Footnotes</h2>
  <div>
    <p class="footnote">
      <a name="terminology"/>
      Some terminology: 
      A <str>TeX document</str> consists of a combination of text to typeset
      and (low-level) TeX commands to do the typesetting.  
      A <str>LaTeX document</str> consists of a combination of text to
      typeset and (higher-level) LaTeX commands to do the typesetting.
      A <str>LuaTeX document</str> consists of a combination of text
      to typeset and (higher-level) LaTeX commands to do the typesetting
      <em>and</em> (optionally) Lua code to do crazy things.
      A TeX document 
      is processed by a <str>TeX engine</str>, an executable program,
      to produce a typeset document, in some format.
      Most TeX engines provide a LaTeX variant that processes LaTeX documents.
      The original TeX engine provides a <code>latex</code> program to
      typeset a LaTeX document in DVI format.
      The pdfTeX engine provides a <code>pdflatex</code> program to
      typeset a LaTeX document in PDF format.
      The LuaTeX engine provides a <code>lualatex</code> program to
      typeset a LuaTeX document in PDF format <em>and</em> a 
      <code>dvilualatex</code> program to 
      typeset a LuaTeX document in DVI format.
    </p>
  </div>

  <hr/>
  <p>
    <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/"><img class="CC"
    alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span
    xmlns:dct="http://purl.org/dc/terms/"
    property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#"
    property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>

  <script><![CDATA[
  var pdfcanvas = document.querySelectorAll("canvas.pdf");

  function renderPDF(i) {
    var canvas = pdfcanvas[i];
    var canvasid = canvas.id;
    console.log("loop " + canvasid);
    var loadingTask = pdfjsLib.getDocument(canvasid + '.pdf');
    loadingTask.promise.then(function(pdf) {
        pdf.getPage(1).then(function(page) {
            console.log("pdf" + canvasid);
            var scale = canvas.getAttribute("scale");
            if (!scale) {
                scale = 100/72;
            }
            var viewport = page.getViewport({ scale: scale, });
            var context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            var renderContext = {
                  canvasContext: context,
                  viewport: viewport
              };
            var renderTask = page.render(renderContext);
            renderTask.promise.then(function() {
                if (i + 1 < pdfcanvas.length) {
                    renderPDF(i + 1)
                }
            });   
         });
    });
  }

  function loadPDFs() {
    if (pdfcanvas.length > 0) {
        renderPDF(0);
    }
  }

  loadPDFs();
  ]]>
  </script>

</body>
</html>
